- name: check for lxc container existance
  shell: "[ -d /var/lib/lxc/{{ vm_name }} ] && echo true || echo false"
  register: lxc_existance
  ignore_errors: true
  changed_when: false
- block:
    - name: check if lxc cache exists
      stat: path=/var/cache/lxc/debian/rootfs-{{ distro }}-amd64/
      register: lxc_cache_dir
    - name: fix cached resolv.conf
      template:
          src: resolv.conf.j2
          dest: /var/cache/lxc/debian/rootfs-{{ distro }}-amd64/etc/resolv.conf
      when: lxc_cache_dir.stat.exists
    - name: create the lxc container
      lxc_container:
          name: "{{ vm_name }}"
          backing_store: lvm
          vg_name: "{{ inventory_hostname }}vg"
          lv_name: "vm_{{ vm_name }}"
          fs_type: xfs
          container_log: true
          template: debian
          template_options: --release {{ distro }} --packages=ssh,python
          container_command: |
              echo "ssh-rsa {{ user_ca_key }}" > /etc/ssh/user_ca.pub
              echo "TrustedUserCAKeys /etc/ssh/user_ca.pub" >> /etc/ssh/sshd_config
              sed -i 's/iface eth0 inet dhcp/iface eth0 inet manual/' /etc/network/interfaces
          state: stopped
    - name: deploy container config
      template: src=config.j2 dest="/var/lib/lxc/{{ vm_name }}/config"
    - name: update container DNS configuration
      template: src=resolv.conf.j2 dest="/var/lib/lxc/{{ vm_name }}/resolv.conf"
      register: container_config_update
    - name: start container
      lxc_container:
          name: "{{ vm_name }}"
          state: started
      when: auto_start|bool
  when: "lxc_existance.stdout == 'false'"
- block:
    - name: check if cert key exist
      shell: lxc-attach -n {{ vm_name }} --clear-env -e -- bash -c "ls /etc/ssh/ssh_host_ed25519_key-cert.pub"
      register: cert_key
      ignore_errors: true
    - block:
        - name: get pub key
          shell: lxc-attach -n {{ vm_name }} --clear-env -e -- bash -c "cat /etc/ssh/ssh_host_ed25519_key.pub"
          register: pub_key
        - debug: var=pub_key
        - name
          local_action: 
      when: "cert_key.rc != 0"
    - name: install packages
      shell: lxc-attach -n {{ vm_name }} --clear-env -e -- bash -c "apt-get install python ssh -y"
      register: shell_result
      changed_when: "shell_result.stdout.find('0 newly installed') == -1"
    - name: update container user ca key
      shell: lxc-attach -n {{ vm_name }} --clear-env -e -- bash -c "grep -F 'ssh-rsa {{ user_ca_key }}' /etc/ssh/user_ca.pub || echo 'ssh-rsa {{ user_ca_key }}' > /etc/ssh/user_ca.pub"
      register: shell_result
      changed_when: "shell_result.stdout != 'ssh-rsa {{ user_ca_key }}'"
    - name: trust user ca key
      shell: lxc-attach -n {{ vm_name }} --clear-env -e -- bash -c "grep -F 'TrustedUserCAKeys /etc/ssh/user_ca.pub' /etc/ssh/sshd_config || echo 'TrustedUserCAKeys /etc/ssh/user_ca.pub' >> /etc/ssh/sshd_config"
      register: shell_result
      changed_when: "shell_result.stdout != 'TrustedUserCAKeys /etc/ssh/user_ca.pub'"
    - name: update container network configuration
      shell: lxc-attach -n {{ vm_name }} --clear-env -e -- bash -c "grep -F 'iface eth0 inet manual' /etc/network/interfaces || sed -i 's/iface eth0 inet dhcp/iface eth0 inet manual/' /etc/network/interfaces"
      register: shell_result
      changed_when: "shell_result.stdout != 'iface eth0 inet manual'"
    - name: update container config
      template: src=config.j2 dest="/var/lib/lxc/{{ vm_name }}/config"
      register: container_config_update
    - name: update container DNS configuration
      template: src=resolv.conf.j2 dest="/var/lib/lxc/{{ vm_name }}/resolv.conf"
      register: container_config_update
    - name: restart container
      lxc_container:
          name: "{{ vm_name }}"
          state: restarted
      when: container_config_update.changed
    - name: set container running state
      lxc_container:
          name: "{{ vm_name }}"
          state: "{{ container_state }}"
  when: "lxc_existance.stdout == 'true'"
- name: "waiting for ssh on {{ vm_name }} vm to start"
  wait_for: host="{{ hostvars[vm_name]['ansible_host'] }}" port=22 timeout=20
